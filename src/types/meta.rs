use std::collections::{HashMap, HashSet};
use std::fmt::Debug;
use std::path::{Path, PathBuf};

use color_eyre::eyre::{Result, WrapErr};
use itertools::Itertools;
use serde::{Deserialize, Serialize};
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tracing::{debug, instrument};

use crate::types::version::VersionNumber;

const DEFAULT_JVM_ARGS: &[&str] = &["-Xms4G", "-Xmx4G"];
const DEFAULT_SERVER_ARGS: &[&str] = &["--nogui"];

pub(crate) trait ToArgs: Sized {
    fn to_args(self) -> Vec<String>;

    fn to_args_string(self) -> String {
        // preserve quotes
        self.to_args()
            .iter()
            .map(|s| shell_escape::escape(s.into()))
            .join(" ")
    }
}

impl<T, S> ToArgs for T
where
    T: IntoIterator<Item = S>,
    S: AsRef<str>,
{
    fn to_args(self) -> Vec<String> {
        self.into_iter().map(|s| s.as_ref().to_string()).collect()
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct InstanceJavaSettings {
    /// The major version of the JVM to use
    ///
    /// Will be either 8, 16, or 17 by default,
    /// depending on the server version
    pub version: u8,
    /// The arguments to pass to the JVM
    pub args: Vec<String>,
}

impl InstanceJavaSettings {
    pub fn new(version: u8) -> Self {
        Self {
            version,
            args: DEFAULT_JVM_ARGS.to_args(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct InstanceServerSettings {
    /// The path to the server jar file, relative to the instance directory
    pub jar: PathBuf,
    /// The arguments to pass to the server
    pub args: Vec<String>,
}

impl Default for InstanceServerSettings {
    fn default() -> Self {
        Self {
            jar: PathBuf::from("server.jar"),
            args: DEFAULT_SERVER_ARGS.to_args(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct InstanceSettings {
    /// The settings for the JVM
    pub java: InstanceJavaSettings,
    /// The settings relating to the server
    pub server: InstanceServerSettings,
}

impl InstanceSettings {
    pub fn new(version: u8) -> Self {
        Self {
            java: InstanceJavaSettings::new(version),
            server: InstanceServerSettings::default(),
        }
    }

    #[instrument(err)]
    pub async fn from_file(path: impl AsRef<Path> + Debug) -> Result<Self> {
        debug!("Reading instance settings");

        let path = path.as_ref();
        let mut file = fs::File::open(path)
            .await
            .wrap_err(format!("Error reading settings at {}", path.display()))?;

        let mut contents = String::new();
        file.read_to_string(&mut contents)
            .await
            .wrap_err(format!("Error reading settings at {}", path.display()))?;

        let settings: Self = toml::from_str(&contents)
            .wrap_err(format!("Error parsing settings at {}", path.display()))?;

        Ok(settings)
    }

    #[instrument(err, ret(level = "debug"), skip(self))]
    pub async fn save(&self, path: impl AsRef<Path> + Debug) -> Result<()> {
        debug!("Saving instance settings");

        let path = path.as_ref();
        fs::create_dir_all(path.parent().expect("infallible")).await?;
        let mut file = fs::File::create(path).await.wrap_err(format!(
            "Error creating settings file at {}",
            path.display()
        ))?;

        let mut contents =
            "# This file is automatically generated\n# Only edit if you know what you're doing!\n\n"
                .to_string();
        contents.push_str(&toml::to_string(self)?);

        file.write_all(contents.as_bytes()).await.wrap_err(format!(
            "Error writing settings to file at {}",
            path.display()
        ))?;

        debug!(settings = ?self, "Saved instance settings");
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub(crate) struct InstanceMeta {
    pub id: VersionNumber,
    pub files: Vec<PathBuf>,
    pub jre: u8, // String?
}

impl InstanceMeta {
    pub fn new(id: VersionNumber, jre: u8) -> Self {
        Self {
            id,
            files: Vec::new(),
            jre,
        }
    }

    #[instrument(skip(self, file), fields(id = %self.id))]
    pub fn add_file(&mut self, file: &Path) {
        debug!(?file, "Adding file");
        self.files.push(file.to_path_buf());
    }

    #[instrument(skip(self, file), fields(id = %self.id))]
    pub fn remove_file(&mut self, file: &PathBuf) {
        debug!(?file, "Removing file");
        self.files.retain(|f| f != file);
    }
}

#[derive(Debug, Default, Serialize, Deserialize)]
pub(crate) struct AppMeta {
    // keyed by id for now, possibly changed later to allow for multiple instances with the same version
    pub instances: HashMap<String, InstanceMeta>,
    pub installed_jres: HashSet<u8>, // String?
    path: PathBuf,
}

impl AppMeta {
    pub fn new(path: PathBuf) -> Self {
        Self {
            instances: HashMap::new(),
            installed_jres: HashSet::new(),
            path,
        }
    }

    #[instrument(err)]
    pub fn from_file(path: impl AsRef<Path> + Debug) -> Result<Self> {
        debug!("Reading meta");

        let path = path.as_ref();
        let data =
            std::fs::read(path).wrap_err(format!("Error reading meta at {}", path.display()))?;

        let meta: Self = rmp_serde::from_slice(&data)
            .wrap_err(format!("Error parsing meta at {}", path.display()))?;

        Ok(meta)
    }

    pub fn save(&self) -> Result<()> {
        self.save_at(&self.path)
    }

    #[instrument(err, ret(level = "debug"), skip(self))]
    pub fn save_at(&self, path: impl AsRef<Path> + Debug) -> Result<()> {
        debug!("Saving meta");

        let path = path.as_ref();
        std::fs::create_dir_all(path.parent().expect("infallible"))?;
        let data = rmp_serde::to_vec(self)
            .wrap_err(format!("Error serializing meta at {}", path.display()))?;

        std::fs::write(path, data).wrap_err(format!("Error writing meta at {}", path.display()))?;

        Ok(())
    }

    #[instrument(skip(path))]
    pub fn read_or_create(path: impl AsRef<Path> + Debug) -> Self {
        let path = path.as_ref();
        if let Ok(mut meta) = Self::from_file(path) {
            debug!("Meta read successfully");
            meta.path = path.to_path_buf(); // this shouldn't be necessary, but it's here just in case
            meta
        } else {
            debug!("Meta not found, creating");
            let meta = Self::new(path.to_path_buf());
            meta.save().expect("Error saving meta"); // TODO: handle error
            meta
        }
    }

    #[instrument(skip(self, instance), fields(id = %instance.id))]
    pub fn add_instance(&mut self, instance: InstanceMeta) {
        debug!("Adding instance {:?}", instance);
        self.instances.insert(instance.id.to_string(), instance);
    }

    #[instrument(ret(level = "debug"), skip(self))]
    pub fn remove_instance(&mut self, id: &String) -> Option<InstanceMeta> {
        debug!("Removing instance");
        self.instances.remove(id)
    }

    #[instrument(skip(self))]
    pub fn instance_installed(&self, id: &String) -> bool {
        self.instances.contains_key(id)
    }

    #[instrument(skip(self))]
    pub fn add_jre(&mut self, jre: u8) -> bool {
        debug!("Adding JRE");
        self.installed_jres.insert(jre)
    }

    #[instrument(skip(self))]
    pub fn remove_jre(&mut self, jre: &u8) -> bool {
        debug!("Removing JRE");
        self.installed_jres.remove(jre)
    }

    #[instrument(skip(self))]
    pub fn jre_installed(&self, jre: &u8) -> bool {
        self.installed_jres.contains(jre)
    }
}

#[cfg(test)]
mod tests {
    use rand::distr::{Alphanumeric, SampleString};

    use super::*;

    #[tokio::test]
    async fn read_write_settings() {
        let suf: String = Alphanumeric.sample_string(&mut rand::rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        scopeguard::defer! {
            std::fs::remove_file(&path).unwrap();
        }

        let settings = InstanceSettings::new(8);
        settings.save(&path).await.unwrap();
        let settings = InstanceSettings::from_file(&path).await.unwrap();
        assert_eq!(settings.java.version, 8);
        assert_eq!(
            settings.java.args,
            DEFAULT_JVM_ARGS
                .iter()
                .map(|s| s.to_string())
                .collect::<Vec<String>>()
        );
        assert_eq!(settings.server.jar, PathBuf::from("server.jar"));
        assert_eq!(settings.server.args, vec!["--nogui".to_string()]);
    }

    #[tokio::test]
    #[should_panic = "Error reading settings at settings-"]
    async fn read_settings_nonexistent() {
        let suf: String = Alphanumeric.sample_string(&mut rand::rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        let _settings = InstanceSettings::from_file(&path).await.unwrap();
    }

    #[tokio::test]
    #[should_panic = "TOML parse error"]
    async fn read_settings_invalid() {
        let suf: String = Alphanumeric.sample_string(&mut rand::rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        scopeguard::defer! {
            std::fs::remove_file(&path).unwrap();
        }

        fs::write(&path, "invalid").await.unwrap();
        let _settings = InstanceSettings::from_file(&path).await.unwrap();
    }
}
